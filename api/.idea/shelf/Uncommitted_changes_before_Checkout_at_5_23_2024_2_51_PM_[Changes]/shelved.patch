Index: app/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nfrom flask import Flask, send_from_directory\r\nfrom .api import api_bp\r\nfrom .twitter_oauth import twitter_bp\r\n# from .process import TweetSentimentAnalyzer\r\n\r\n\r\ndef create_app():\r\n    app = Flask(__name__, static_folder='build')\r\n    \r\n    app.register_blueprint(api_bp, url_prefix='/api')\r\n    app.register_blueprint(twitter_bp)\r\n\r\n    # Initialize and train the sentiment model\r\n    # train_path = os.environ.get('TRAIN_PATH')\r\n    # val_path = os.environ.get('VAL_PATH')\r\n    # test_path = os.environ.get('TEST_PATH')\r\n    # app.config['sentiment_model'] = TweetSentimentAnalyzer(train_path, val_path, test_path)\r\n    \r\n    @app.route('/', defaults={'path': ''})\r\n    @app.route('/<path:path>')\r\n    def serve(path):\r\n        if path != \"\" and os.path.exists(os.path.join(app.static_folder, path)):\r\n            return send_from_directory(app.static_folder, path)\r\n        else:\r\n            return send_from_directory(app.static_folder, 'index.html')\r\n\r\n    return app\r\n
===================================================================
diff --git a/app/__init__.py b/app/__init__.py
--- a/app/__init__.py	
+++ b/app/__init__.py	
@@ -2,7 +2,7 @@
 from flask import Flask, send_from_directory
 from .api import api_bp
 from .twitter_oauth import twitter_bp
-# from .process import TweetSentimentAnalyzer
+from .process import TweetSentimentAnalyzer
 
 
 def create_app():
@@ -12,10 +12,11 @@
     app.register_blueprint(twitter_bp)
 
     # Initialize and train the sentiment model
-    # train_path = os.environ.get('TRAIN_PATH')
-    # val_path = os.environ.get('VAL_PATH')
-    # test_path = os.environ.get('TEST_PATH')
-    # app.config['sentiment_model'] = TweetSentimentAnalyzer(train_path, val_path, test_path)
+    train_path = os.environ.get('TRAIN_PATH')
+    val_path = os.environ.get('VAL_PATH')
+    test_path = os.environ.get('TEST_PATH')
+    model = process.TweetSentimentAnalyzer(train_path, val_path, test_path)
+    app.config['sentiment_model'] = model
     
     @app.route('/', defaults={'path': ''})
     @app.route('/<path:path>')
Index: app/twitter_oauth.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport re\r\nimport base64\r\nimport hashlib\r\n\r\nimport requests\r\nfrom requests_oauthlib import OAuth2Session\r\nfrom flask import Blueprint, request, redirect, jsonify, session\r\n\r\ntwitter_bp = Blueprint('twitter', __name__)\r\n\r\nREDIRECT_URI=os.environ['REDIRECT_URI']\r\nCLIENT_ID = os.environ['CLIENT_ID']\r\nCLIENT_KEY = os.environ['CLIENT_KEY']\r\nREDIRECT_URI = os.environ['REDIRECT_URI']\r\nACCESS_TOKEN_URL = os.environ['ACCESS_TOKEN_URL']\r\nAUTHORIZE_URL = os.environ['AUTHORIZE_URL']\r\nUSER_TIMELINE_URL = os.environ['USER_TIMELINE_URL']\r\nUSER_TWEETS_URL = os.environ['USER_TWEETS_URL']\r\nAPI_USERS_ENDPOINT = os.environ['API_USERS_ENDPOINT']\r\n\r\ncode_verifier = base64.urlsafe_b64encode(os.urandom(30)).decode(\"utf-8\")\r\ncode_verifier = re.sub(\"[^a-zA-Z0-9]+\", \"\", code_verifier)\r\n\r\ncode_challenge = hashlib.sha256(code_verifier.encode(\"utf-8\")).digest()\r\ncode_challenge = base64.urlsafe_b64encode(code_challenge).decode(\"utf-8\")\r\ncode_challenge = code_challenge.replace(\"=\", \"\")\r\n\r\nscopes = ['tweet.read', 'users.read', 'follows.read', 'follows.write']\r\n                       \r\n\r\n@twitter_bp.route('/authorize/twitter')\r\ndef twitter_info():\r\n    global twitter\r\n    twitter = OAuth2Session(\r\n        client_id=CLIENT_ID,\r\n        scope=scopes,\r\n        redirect_uri=REDIRECT_URI\r\n    )\r\n    auth_url, state = twitter.authorization_url(\r\n        AUTHORIZE_URL, code_challenge=code_challenge, code_challenge_method='S256'\r\n    )\r\n    session[\"oauth_state\"] = state\r\n    \r\n    return redirect(auth_url)\r\n\r\n\r\n@twitter_bp.route('/callback', methods=[\"GET\"])\r\ndef process_user():\r\n    code = request.args.get('code')\r\n\r\n    # for offline access, you would also need to call for a bearer token as well as an access token here\r\n    token = twitter.fetch_token(\r\n        token_url=ACCESS_TOKEN_URL,\r\n        client_secret=CLIENT_KEY,\r\n        code_verifier=code_verifier,\r\n        code=code\r\n    )\r\n    user_info = requests.request(\r\n        \"GET\", \r\n        API_USERS_ENDPOINT + 'me',\r\n        headers={\"Authorization\": f'Bearer {token[\"access_token\"]}'}\r\n    ).json()\r\n\r\n    user_id = user_info[\"data\"][\"id\"]\r\n    username = user_info[\"data\"][\"username\"]\r\n    \r\n    user_tweets = requests.request(\r\n        \"GET\", \r\n        API_USERS_ENDPOINT + user_id + USER_TWEETS_URL,\r\n        headers={\"Authorization\": f'Bearer {token[\"access_token\"]}'}, \r\n        params={'max_results': 25}\r\n    ).json()\r\n    user_timeline = requests.request(\r\n        \"GET\", \r\n        API_USERS_ENDPOINT + user_id + USER_TIMELINE_URL,\r\n        headers={\"Authorization\": f'Bearer {token[\"access_token\"]}'},\r\n        params={'max_results': 25}\r\n    ).json()\r\n\r\n    return jsonify(user_id, username, user_tweets, user_timeline)\r\n\r\n# @twitter_bp.route('/logout')\r\n# def logout():\r\n#     global oauth_store\r\n#     oauth_store = {}\r\n#     return redirect('/')\r\n
===================================================================
diff --git a/app/twitter_oauth.py b/app/twitter_oauth.py
--- a/app/twitter_oauth.py	
+++ b/app/twitter_oauth.py	
@@ -7,12 +7,14 @@
 from requests_oauthlib import OAuth2Session
 from flask import Blueprint, request, redirect, jsonify, session
 
+from dotenv import load_dotenv
+load_dotenv()
+
 twitter_bp = Blueprint('twitter', __name__)
 
-REDIRECT_URI=os.environ['REDIRECT_URI']
+REDIRECT_URI = os.environ['REDIRECT_URI']
 CLIENT_ID = os.environ['CLIENT_ID']
 CLIENT_KEY = os.environ['CLIENT_KEY']
-REDIRECT_URI = os.environ['REDIRECT_URI']
 ACCESS_TOKEN_URL = os.environ['ACCESS_TOKEN_URL']
 AUTHORIZE_URL = os.environ['AUTHORIZE_URL']
 USER_TIMELINE_URL = os.environ['USER_TIMELINE_URL']
Index: app/process.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import tensorflow as tf\r\nimport numpy as np\r\nimport random\r\nfrom vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer\r\nfrom keras.preprocessing.text import Tokenizer\r\nfrom keras.preprocessing.sequence import pad_sequences\r\nfrom sklearn.metrics import confusion_matrix\r\nimport pandas as pd\r\n\r\n\r\nclass TweetSentimentAnalyzer:\r\n    def __init__(self, train_path, val_path, test_path):\r\n        self.maxlen = 50\r\n        self.tokenizer = Tokenizer(num_words=10000, oov_token=\"<UNK>\")\r\n        self.analyzer = SentimentIntensityAnalyzer()\r\n        self.classes = None\r\n        self.class_to_index = None\r\n        self.index_to_class = None\r\n\r\n        self.train_data = self.load_data(train_path)\r\n        self.val_data = self.load_data(val_path)\r\n        self.test_data = self.load_data(test_path)\r\n\r\n        self.train_tweets, self.train_labels = self.get_tweet(self.train_data)\r\n        self.val_tweets, self.val_labels = self.get_tweet(self.val_data)\r\n        self.test_tweets = self.get_tweet_without_labels(self.test_data)\r\n\r\n        self.tokenizer.fit_on_texts(self.train_tweets)\r\n        self.padded_train_sequences = self.get_sequences(self.train_tweets)\r\n        self.val_sequences = self.get_sequences(self.val_tweets)\r\n        self.test_sequences = self.get_sequences(self.test_tweets)\r\n\r\n        self.classes = set(self.train_labels)\r\n        self.class_to_index = dict((c, i) for i, c in enumerate(self.classes))\r\n        self.index_to_class = dict((value, key) for key, value in self.class_to_index.items())\r\n\r\n        self.model = self.create_model()\r\n        self.train_model()\r\n        self.evaluate_model()\r\n        self.predict()\r\n\r\n    def load_data(self, path):\r\n        return pd.read_csv(path, sep=\";\", names=[\"text\", \"label\"])\r\n\r\n    def get_tweet(self, data):\r\n        tweets = data[\"text\"]\r\n        labels = data[\"label\"]\r\n        return tweets, labels\r\n\r\n    def get_tweet_without_labels(self, data):\r\n        return data[\"text\"]\r\n\r\n    def get_sequences(self, tweets):\r\n        sequences = self.tokenizer.texts_to_sequences(tweets)\r\n        padded_sequences = pad_sequences(sequences, truncating='post', padding='post', maxlen=self.maxlen)\r\n        return padded_sequences\r\n\r\n    def get_sentiment_score(self, text):\r\n        sentiment_dict = self.analyzer.polarity_scores(text)\r\n        return sentiment_dict['compound']\r\n\r\n    def create_model(self):\r\n        model = tf.keras.Sequential([\r\n            tf.keras.layers.Embedding(10000, 16, input_length=self.maxlen),\r\n            tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(20, return_sequences=True)),\r\n            tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(20)),\r\n            tf.keras.layers.Dense(6, activation='softmax')\r\n        ])\r\n        model.compile(\r\n            loss='sparse_categorical_crossentropy',\r\n            optimizer='adam',\r\n            metrics=['accuracy']\r\n        )\r\n        return model\r\n\r\n    def predict_emotion(self, sequence):\r\n        p = self.model.predict(np.expand_dims(sequence, axis=0))[0]\r\n        pred_class = self.index_to_class[np.argmax(p).astype('uint8')]\r\n        return pred_class\r\n\r\n\r\n\r\n    def predict_emotion_probability(self, sequence):\r\n        p = self.model.predict(np.expand_dims(sequence, axis=0))[0]\r\n        pred_class_index = np.argmax(p)\r\n        intensity = p[pred_class_index]\r\n        return intensity\r\n\r\n    def calculate_sentiment_per_tweet(self,tweetdict):\r\n        predicted_sent_per_tweet = dict[\"tweet_id\", \"predicted_sentiment\", \"intensity_level\"]\r\n        for tw_id, tweet in tweetdict['tweet_id', 'text']:\r\n            tweet_sequence = self.get_sequences(tweet)\r\n            predicted_sentiment = self.predict_emotion(tweet_sequence)\r\n            intensity = self.predict_emotion_probability(\r\n                tweet_sequence) * self.get_sentiment_score(tweet)\r\n            keys = [\"tweet_id\", \"predicted_sentiment\", \"intensity_level\"]\r\n            values = [tw_id, predicted_sentiment, intensity]\r\n            predicted_sent_per_tweet.update = {k: v for k, v in zip(keys, values)}\r\n        return predicted_sent_per_tweet\r\n\r\n    def calculate_total_intensity(self, tweets):\r\n        total_intensity = {\r\n            'anger': 0,\r\n            'joy': 0,\r\n            'sadness': 0,\r\n            'fear': 0,\r\n            'surprise': 0,\r\n            'love': 0\r\n        }\r\n\r\n        for tweet in tweets:\r\n            tweet_sequence = self.get_sequences([tweet['text']])[0]\r\n            predicted_sentiment = self.predict_emotion(tweet_sequence)\r\n            intensity = self.predict_emotion_probability(tweet_sequence)\r\n\r\n            total_intensity[predicted_sentiment] += intensity\r\n\r\n        return total_intensity\r\n\r\n    def train_model(self):\r\n        m = self.model.fit(\r\n            self.padded_train_sequences,\r\n            self.train_labels,\r\n            validation_data=(self.val_sequences, self.val_labels),\r\n            epochs=20,\r\n            callbacks=[\r\n                tf.keras.callbacks.EarlyStopping(monitor='val_accuracy', patience=2)\r\n            ]\r\n        )\r\n\r\n    def evaluate_model(self):\r\n        _ = self.model.evaluate(self.test_sequences)\r\n\r\n    def predict(self):\r\n        predict_x = self.model.predict(self.test_sequences)\r\n        classes_x = np.argmax(predict_x, axis=1)\r\n\r\n        \"\"\"for _ in range(5):\r\n            i = random.randint(0, len(self.test_tweets) - 1)\r\n            print(\"Tweet : \", self.test_tweets[i])\r\n            intensity_score = abs(self.get_sentiment_score(self.test_tweets[i]))\r\n            pred_class = self.predict_emotion(self.test_sequences[i])\r\n            pred_intensity = self.predict_emotion_probability(self.test_sequences[i])\r\n            print(\"predicted label : \", pred_class)\r\n            print(\"intensity or probability of emotion: {:.2f}\".format(pred_intensity))\r\n            print(\"sentiment score from VADER: \", intensity_score)\r\n            print(\"-----------------------\\n\")\"\"\"\r\n\r\n    def main(self,tweetdict,timelinedict):\r\n        pertweet_sentiment_dict = self.calculate_sentiment_per_tweet(tweetdict)\r\n        total_intensity_user = self.calculate_total_intensity(list(tweetdict[\"text\"]))\r\n        total_intensity_timeline = self.calculate_total_intensity(list(timelinedict[\"text\"]))\r\n        overall_results = {\r\n            \"total_anger_intensity_level\": total_intensity_user[\"anger\"],\r\n            \"total_joy_intensity_level\": total_intensity_user[\"joy\"],\r\n            \"total_sadness_intensity_level\": total_intensity_user[\"sadness\"],\r\n\r\n            \"timeline_anger_intensity_level\": total_intensity_timeline[\"anger\"],\r\n            \"timeline_joy_intensity_level\": total_intensity_timeline[\"joy\"],\r\n            \"timeline_sadness_intensity_level\": total_intensity_timeline[\"sadness\"]\r\n        }\r\n        return overall_results, pertweet_sentiment_dict\r\n
===================================================================
diff --git a/app/process.py b/app/process.py
--- a/app/process.py	
+++ b/app/process.py	
@@ -2,8 +2,8 @@
 import numpy as np
 import random
 from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
-from keras.preprocessing.text import Tokenizer
-from keras.preprocessing.sequence import pad_sequences
+from tensorflow.keras.preprocessing.text import Tokenizer
+from tensorflow.keras.preprocessing.sequence import pad_sequences
 from sklearn.metrics import confusion_matrix
 import pandas as pd
 
